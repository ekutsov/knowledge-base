# GarbageCollector

Сборщик мусора в .NET Framework управляет памятью для управляемых приложений. Он периодически проверяет наличие в памяти объектов, которые больше не используются приложением, и освобождает память, занимаемую этими объектами. Сборщик мусора использует концепцию, называемую поколениями, для управления памятью. Объекты группируются в различные поколения в зависимости от того, как долго они находились в памяти. В сборщике мусора .NET существует три поколения:



**Поколение 0**: Это самое молодое поколение, которое содержит недавно созданные объекты. Сборщик мусора часто проверяет это поколение на наличие подходящих для сбора объектов, поскольку они, скорее всего, недолговечны и больше не используются.

**Поколение 1**: Это поколение содержит объекты, которые пережили одну сборку мусора и считаются немного старше. Сборщик мусора проверяет это поколение реже, чем поколение 0.

**Поколение 2**: Это самое старое поколение, содержащее объекты, которые пережили несколько сборов мусора. Эти объекты, как правило, живут дольше и реже собираются. Сборщик мусора проверяет это поколение нечасто.

Сборщик мусора использует этот подход к поколениям для оптимизации процесса сбора, поскольку эффективнее чаще проверять самое молодое поколение, так как в нем, скорее всего, будет больше объектов, подходящих для сбора.

Стоит отметить, что сборщик мусора управляет не только кучей, но и кучей больших объектов (Large Object Heap, LOH), которая используется для объектов, размер которых превышает определенный порог (по умолчанию 85 КБ).


Вот несколько вопросов для интервью по этой теме с примерами ответов:

- **В: Как сборщик мусора определяет, какие объекты нужно собрать?**<br>
  О: Сборщик мусора использует алгоритм mark-and-sweep, чтобы определить, какие объекты больше не используются приложением. Он начинает с определения набора "корневых" объектов, таких как статические переменные и ссылки на стеке, а затем рекурсивно "помечает" все достижимые объекты из этих корней. Любые объекты, которые не помечены, считаются пригодными для сбора.

- **В: Что такое управляемая куча?**<br>
  О: Управляемая куча - это область памяти, в которой сборщик мусора выделяет память для управляемых объектов. Когда приложение создает новый объект, среда выполнения выделяет память для этого объекта в управляемой куче. Сборщик мусора отвечает за управление этой кучей, включая выделение и освобождение памяти по мере необходимости.

- **В: Что такое финализатор в .NET?**<br>
  О: Финализатор - это метод, который вызывается сборщиком мусора непосредственно перед тем, как объект будет собран. Финализаторы используются для выполнения задач     очистки, которые не являются критическими для работы приложения, например, для освобождения неуправляемых ресурсов. Финализатор определяется путем реализации в      классе метода <br>
  ``protected override void Finalize()``.

- **В: В чем разница между управляемым и неуправляемым ресурсом?**<br>
  О: Управляемые ресурсы - это объекты, которые управляются сборщиком мусора, например, объекты на управляемой куче. Неуправляемые ресурсы - это ресурсы, которые не управляются сборщиком мусора, например, дескрипторы файлов или соединения баз данных. Приложение несет ответственность за явное освобождение неуправляемых ресурсов, когда они больше не нужны, обычно в финализаторе.
  
  Интерфейс IDisposable - это общий интерфейс в C#, определяющий единственный метод Dispose(), который используется для освобождения ресурсов, принадлежащих объекту. Классы, реализующие IDisposable, обычно используются для управления ресурсами, которые дорого создавать или приобретать, такими как соединения баз данных, дескрипторы файлов и сетевые сокеты.

Метод Dispose() обычно используется для освобождения этих ресурсов и предоставления их в пользование другим частям системы. Важно вызывать метод Dispose(), когда объект, реализующий IDisposable, больше не нужен, чтобы избежать утечек памяти и других проблем, связанных с ресурсами.

## IDisposable
При реализации IDisposable в классе, класс также должен иметь финализатор, вызывающий Dispose().

Классы, реализующие IDisposable, могут использовать оператор "using", который автоматически вызывает Dispose(), когда блок кода, использующий объект, завершает выполнение. Оператор using - это конструкция C#, которая упрощает использование классов, реализующих IDisposable, автоматически вызывая Dispose() при завершении блока using.

Оператор "using" в C# - это сокращение для блока try-finally. Когда вы используете оператор "using", компилятор C# автоматически генерирует код, который создает экземпляр указанного объекта, а затем оборачивает его в блок try-finally.

Код, выполняемый в блоке using, помещается в блок try сгенерированного оператора try-finally, а вызов метода Dispose() для объекта помещается в блок finally.

Оператор "using" транслируется в следующий код:
```cs
{
    Object obj = new Object();
    try
    {
        // Код внутри блока using
    }
    finally
    {
        if (obj != null)
        {
            ((IDisposable)obj).Dispose();
        }
    }
}
```
Созданный блок try-finally гарантирует, что метод Dispose() будет вызван, даже если в блоке using возникнет исключение. Это позволяет легко убедиться, что ресурсы очищены должным образом, независимо от того, успешно или нет завершается код в блоке using.
