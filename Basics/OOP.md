# OOP (Object-Oriented Programming)

Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая использует объекты и их взаимодействие для проектирования приложений и компьютерных программ. Она основана на концепции объектов, которые обладают определенными свойствами и поведением, а взаимодействия между этими объектами используются для проектирования программы.

Основными принципами ООП являются:

- **Инкапсуляция**: Это практика сокрытия внутренних деталей объекта и раскрытия только публичного интерфейса. Это позволяет изменять реализацию объекта, не затрагивая остальную часть программы.

- **Абстракция**: Это процесс определения основных характеристик объекта и игнорирования несущественных деталей. Это позволяет определять объекты на высоком уровне абстракции, что делает их более простыми для понимания и использования.

- **Наследование**: Это процесс создания нового класса, который наследует свойства и поведение существующего класса. Это позволяет определять новые классы, которые похожи на существующие, сокращая объем кода, который необходимо написать.

- **Полиморфизм**: Это способность одного интерфейса использоваться с различными типами объектов. Это позволяет одинаково обращаться с объектами разных классов, делая код более гибким и пригодным для повторного использования.

В ООП программа делится на объекты, которые являются экземплярами классов. Классы - это шаблоны, которые определяют свойства и поведение объекта. Объекты создаются из классов и могут использоваться для выполнения действий и хранения данных. ООП также поощряет использование интерфейсов и абстрактных классов, которые обеспечивают общий набор моделей поведения для реализации родственными классами.

Здесь приведены короткие примеры кода на C#, которые иллюстрируют каждый из четырех принципов объектно-ориентированного программирования (ООП):

1. Инкапсуляция:
```
class BankAccount {
    private decimal balance;
    public void Deposit(decimal amount) {
        balance += amount;
    }
    public void Withdraw(decimal amount) {
        if (amount > balance) {
            throw new Exception("Insufficient funds");
        }
        balance -= amount;
    }
    public decimal GetBalance() {
        return balance;
    }
}
```
В этом примере класс ``BankAccount`` инкапсулирует переменную ``balance``, делая ее частной и доступной только через публичные методы ``Deposit``, ``Withdraw`` и ``GetBalance``. Это позволяет изменять реализацию класса ``BankAccount``, не затрагивая остальную часть программы.

2. Абстракция:
```
abstract class Shape {
    public abstract double GetArea();
}
class Square : Shape {
    private double side;
    public Square(double side) {
        this.side = side;
    }
    public override double GetArea() {
        return side * side;
    }
}
class Circle : Shape {
    private double radius;
    public Circle(double radius) {
        this.radius = radius;
    }
    public override double GetArea() {
        return Math.PI * radius * radius;
    }
}
```
В этом примере класс ``Shape`` определен на высоком уровне абстракции, игнорируя несущественные детали конкретных фигур. Классы ``Square`` и ``Circle`` наследуют метод GetArea от класса ``Shape`` и предоставляют собственную реализацию.

3. Наследование:
```
class Animal {
    protected string name;
    public Animal(string name) {
        this.name = name;
    }
    public void Eat() {
        Console.WriteLine(name + " is eating.");
    }
}
class Dog : Animal {
    public Dog(string name) : base(name) {}
    public void Bark() {
        Console.WriteLine(name + " is barking.");
    }
}
```
В этом примере класс ``Dog`` наследуется от класса ``Animal`` и наследует метод ``Eat`` и переменную name.

4. Полиморфизм:
```
abstract class Shape {
    public abstract double GetArea();
}
class Square : Shape {
    private double side;
    public Square(double side) {
        this.side = side;
    }
    public override double GetArea() {
        return side * side;
    }
}
class Circle : Shape {
    private double radius;
    public Circle(double radius) {
        this.radius = radius;
    }
    public override double GetArea() {
        return Math.PI * radius * radius;
    }
}

Shape shape1 = new Square(5);
Shape shape2 = new Circle(3);

Console.WriteLine("Area of square: " + shape1.GetArea());
Console.WriteLine("Area of circle: " + shape2.GetArea());
```
В этом примере класс ``Shape`` определяет общий интерфейс для классов ``Square`` и ``Circle`` с методом ``GetArea``.
Классы ``Square`` и ``Circle`` наследуют от класса ``Shape`` и предоставляют свою собственную реализацию метода ``GetArea``.
Создавая переменные типа ``Shape``, мы можем использовать один и тот же метод ``GetArea`` на объектах разных классов ``Square`` и ``Circle``, что является примером полиморфизма.

В объектно-ориентированном программировании полиморфизм относится к способности одного интерфейса использоваться с различными типами объектов. Существует два типа полиморфизма:

1. Полиморфизм во время компиляции (также известный как статический полиморфизм или перегрузка): Этот тип полиморфизма достигается за счет перегрузки функций или перегрузки операторов. Перегрузка функций происходит, когда несколько функций с одинаковым именем определены в одной области видимости, но с разными списками параметров. Перегрузка операторов происходит, когда операторам, таким как ``+``, ``-``, ``*`` и ``/``, придаются специальные значения для типов, определяемых пользователем.
```
class MathOps {
    public int Add(int a, int b) {
        return a + b;
    }
    public double Add(double a, double b) {
        return a + b;
    }
}
```
В этом примере метод ``Add`` перегружен, чтобы принимать параметры ``int`` и ``double``.

2. Полиморфизм во время выполнения (также известный как динамический полиморфизм или переопределение): Этот тип полиморфизма достигается путем переопределения методов. Переопределение метода происходит, когда подкласс определяет метод с тем же именем и сигнатурой, что и метод в его суперклассе. Считается, что метод подкласса переопределяет метод суперкласса. Когда переопределенный метод вызывается через ссылку на суперкласс, JVM (Java Virtual Machine) определяет реальный класс объекта во время выполнения и вызывает метод, характерный для этого класса.
```
class Shape {
    public virtual void Draw() {
        Console.WriteLine("Drawing a shape.");
    }
}
class Circle : Shape {
    public override void Draw() {
        Console.WriteLine("Drawing a circle.");
    }
}
class Square : Shape {
    public override void Draw() {
        Console.WriteLine("Drawing a square.");
    }
}
```
В этом примере метод ``Draw`` определен как виртуальный в классе ``Shape``, и он переопределен в классах ``Circle`` и ``Square``.
Когда метод ``Draw`` вызывается на объекте типа ``Shape``, во время выполнения определяется реальный класс объекта и вызывается соответствующий переопределенный метод.
