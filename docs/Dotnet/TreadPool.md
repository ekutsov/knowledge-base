<sub>[Главная](../../index.md) / [.NET](README.md) / **Thread Pool** </sub>

# **ThreadPool**

ThreadPool - это класс .NET, который используется для управления пулом рабочих потоков. Он позволяет разработчикам ставить в очередь рабочие элементы, которые затем выполняются потоками в пуле. ThreadPool автоматически управляет созданием и уничтожением потоков, а также предоставляет механизмы для управления количеством потоков и их приоритетами. Он разработан, чтобы быть эффективным и минимизировать накладные расходы на создание и управление потоками. В .NET 5 ThreadPool используется для одновременной обработки нескольких запросов, что повышает производительность приложения.

Вот несколько примеров того, как вы можете использовать ThreadPool в .NET:
1. Выполнение задачи асинхронно:
```cs
ThreadPool.QueueUserWorkItem(new WaitCallback(MyTask), parameter);
```
В этом примере "MyTask" - это метод, который принимает один параметр объекта, а "parameter" - это объект, передаваемый методу. ThreadPool назначит поток из пула для выполнения метода. Это позволяет выполнять задачу асинхронно, без необходимости создавать и управлять собственным потоком.<br><br>
2. Выполнение задания с тайм-аутом:
```cs
ThreadPool.RegisterWaitForSingleObject(
    myEvent, 
    new WaitOrTimerCallback(MyTask), 
    parameter, 
    1000, 
    true
);
```
В этом примере "MyTask" снова является методом, который принимает один параметр объекта, а "parameter" - это объект, который передается методу. ThreadPool назначит поток из пула для ожидания сигнала о событии "myEvent". Если сигнал о событии поступит в течение 1000 миллисекунд, поток выполнит метод "MyTask". Если в течение 1000 миллисекунд сигнал о событии не поступил, поток не будет выполнять метод. Это позволяет выполнять задачу с таймаутом, не создавая и не управляя собственным потоком.

Обратите внимание, что в обоих этих примерах ThreadPool автоматически управляет созданием и уничтожением потоков, что может значительно упростить ваш код и повысить производительность.

Вы также можете установить количество рабочих потоков и потоков порта завершения в ThreadPool, вызвав 
```cs
ThreadPool.SetMinThreads(workerThreads, completionPortThreads);
//and
ThreadPool.SetMaxThreads(workerThreads, completionPortThreads);
```
По умолчанию количество рабочих потоков зависит от количества процессоров, а количество потоков порта завершения - от количества процессоров, умноженного на 2.

Вот несколько конкретных случаев и их решения, с которыми вы можете столкнуться при использовании ThreadPool в .NET:

1. ThreadPool starvation (Голодание):
ThreadPool starvation может возникнуть, когда количество задач, добавляемых в ThreadPool, превышает количество потоков, доступных для их выполнения. Это может привести к накопившимся задачам и вызвать невосприимчивость приложения.
**Решение**:
Используйте ThreadPool.GetAvailableThreads и ThreadPool.GetMaxThreads для мониторинга количества доступных потоков.
Увеличьте количество рабочих потоков и потоков порта завершения, вызвав ThreadPool.SetMinThreads и ThreadPool.SetMaxThreads.
Избегайте создания слишком большого количества задач, которые недолговечны и ставятся в очередь последовательно.

2. ThreadPool oversubscription (Переподписка):
Переподписка ThreadPool может произойти, когда количество потоков, доступных в ThreadPool, превышает количество процессоров на машине. Это может вызвать чрезмерное переключение контекста и привести к низкой производительности.
**Решение**:
Используйте ThreadPool.GetMinThreads и ThreadPool.GetMaxThreads для мониторинга количества потоков в ThreadPool.
Уменьшите количество рабочих потоков и потоков порта завершения, вызвав ThreadPool.SetMinThreads и ThreadPool.SetMaxThreads.
Избегайте создания слишком большого количества длительно выполняющихся задач, которые потребляют большое количество процессорного времени.

3. Тупик из-за ThreadPool:
Тупик может возникнуть, когда задача, выполняемая потоком ThreadPool, блокируется в ожидании другой задачи, которая также выполняется потоком ThreadPool. Это может привести к зависанию приложения.
**Решение**:
Используйте ThreadPool.QueueUserWorkItem для асинхронного выполнения задач и избегайте использования ThreadPool.RegisterWaitForSingleObject.
Вместо ThreadPool используйте Task Parallel Library (TPL), которая предоставляет более высокоуровневую абстракцию для работы с потоками и может помочь вам избежать тупиковых ситуаций.
Важно отметить, что это лишь некоторые примеры проблем, с которыми вы можете столкнуться при использовании ThreadPool, и что предложенные решения могут быть не единственными и не лучшими для всех случаев. Всегда полезно следить за производительностью своего приложения и изучать документацию по .NET, чтобы избежать подобных проблем.
